{"instruction": "Explica la complejidad temporal de la búsqueda binaria.", "response": "La búsqueda binaria tiene una complejidad temporal de O(log n). Esto se debe a que el espacio de búsqueda se reduce a la mitad en cada iteración, logrando una eficiencia logarítmica. Esto solo funciona si la lista está ordenada."}
{"instruction": "Muéstrame el pseudocódigo del algoritmo A* para búsqueda de caminos.", "response": "El algoritmo A* se basa en $f(n) = g(n) + h(n)$. Pseudocódigo:\n\n1. Inicializar OpenSet con el nodo inicial.\n2. Mientras OpenSet no esté vacío:\n3. Seleccionar el nodo 'actual' con el menor $f(n)$.\n4. Si 'actual' es el objetivo, reconstruir el camino y terminar.\n5. Para cada vecino de 'actual', calcular costos y actualizar OpenSet."}
{"instruction": "¿Cuál es la diferencia fundamental entre un grafo dirigido y uno no dirigido?", "response": "En un grafo dirigido, los lados (aristas) tienen una orientación (flechas), lo que significa que la conexión de A a B no es igual a la de B a A. En un grafo no dirigido, no hay orientación y (Vi, Vj) = (Vj, Vi)."}
{"instruction": "Corrige este pseudocódigo de un bucle infinito: i = 1; mientras i > 0, i = i + 1", "response": "El bucle es infinito porque la condición 'i > 0' siempre es verdadera. Corrección: Define un límite superior. Ejemplo: i = 1; mientras i < 10, i = i + 1. De esta forma, el bucle termina en 9."}
{"instruction": "¿Qué es la complejidad O(n^2)? Dame un ejemplo.", "response": "La complejidad O(n^2) (cuadrática) significa que el tiempo de ejecución crece proporcionalmente al cuadrado del tamaño de la entrada. Un ejemplo clásico es un bucle anidado que compara cada elemento con todos los demás, como en el algoritmo de ordenamiento Bubble Sort."}
{"instruction": "Explícame qué es una función hash y por qué son importantes en las estructuras de datos.", "response": "Una función hash toma una entrada y devuelve un valor numérico de longitud fija llamado 'hash'. Son cruciales en las Tablas Hash (HashMaps) porque permiten acceder o insertar datos en tiempo promedio O(1)."}
{"instruction": "Diferencia entre Stack (Pila) y Queue (Cola).", "response": "La diferencia está en el principio de acceso:\n\n* **Stack (Pila):** Utiliza LIFO (Last-In, First-Out). El último en entrar es el primero en salir.\n* **Queue (Cola):** Utiliza FIFO (First-In, First-Out). El primero en entrar es el primero en salir."}
{"instruction": "Estudiante: ¿Por qué mi Insertion Sort falla si la lista está invertida?", "response": "Ese es el peor caso para Insertion Sort, con complejidad O(n^2). Debes asegurar que el bucle interno se detenga cuando la clave esté en su posición correcta. Si buscas estabilidad, usa Merge Sort."}
{"instruction": "Define el término 'Admisible' para una heurística en el algoritmo A*.", "response": "Una función heurística $h(n)$ es admisible si **nunca sobreestima** el costo real para alcanzar la meta desde el nodo $n$ ($h(n) le h^*(n)$). Si es admisible, A* garantiza encontrar el camino más corto (es óptimo)."}
{"instruction": "Pseudocódigo para un recorrido in-order en un Árbol Binario de Búsqueda (BST).", "response": "El recorrido in-order visita en orden ascendente: Izquierdo, Raíz, Derecho. Pseudocódigo:\n\n```pseudocode\nPROCEDURE InOrder(nodo):\n1. SI nodo NO es NULO:\n2.   InOrder(nodo.izquierdo)\n3.   IMPRIMIR(nodo.valor)\n4.   InOrder(nodo.derecho)\nEND FUNCTION\n```"}
{"instruction": "¿Qué problema resuelve el algoritmo de Dijkstra?", "response": "El algoritmo de Dijkstra resuelve el problema de encontrar el camino más corto desde un nodo de inicio hacia todos los demás nodos en un grafo, siempre que todas las aristas tengan pesos **no negativos**."}
{"instruction": "Explícame la diferencia entre BFS (Búsqueda en Anchura) y DFS (Búsqueda en Profundidad).", "response": "BFS (Anchura) explora por niveles, usa una Cola (Queue) y garantiza el camino más corto en número de aristas. DFS (Profundidad) explora una rama hasta el fondo, usa una Pila (Stack) o recursividad, y no garantiza el camino más corto."}
{"instruction": "Quiero usar Quick Sort, ¿cuál es su complejidad en el caso promedio?", "response": "La complejidad promedio de Quick Sort es **O(n log n)**. Es uno de los más rápidos en la práctica, aunque su peor caso es $O(n^2)$."}
{"instruction": "Define el problema de 'los caníbales y los monjes' en términos de espacio de estados.", "response": "El estado se define como (Monjes Oeste, Caníbales Oeste, Monjes Este, Caníbales Este, Posición Canoa). El estado inicial es (3, 3, 0, 0, O) y el final es (0, 0, 3, 3, E). La restricción es que los caníbales nunca deben superar en número a los monjes en ninguna orilla."}
{"instruction": "¿Qué es la maldición de la dimensionalidad en Machine Learning?", "response": "La maldición de la dimensionalidad se refiere a los problemas que surgen al trabajar con datos en espacios de muchas dimensiones. Los datos se vuelven dispersos, y los modelos requieren exponencialmente más datos para generalizar, obligando al uso de la Reducción de Dimensionalidad (PCA)."}
{"instruction": "Explica la estructura básica de un Nodo en un grafo.", "response": "Un Nodo (o Vértice) es un punto en el espacio que almacena información. Lo fundamental es que se define por su valor y una lista de adyacencia (punteros a nodos vecinos)."}
{"instruction": "Para un fine-tuning con LoRA, ¿cuál es el propósito de 'lora_alpha'?", "response": "El parámetro 'lora_alpha' es un factor de escalado que controla la intensidad con la que la nueva información aprendida por los adaptadores LoRA (matrices A y B) se aplica al modelo base. La actualización se escala por ($alpha / r$)."}
{"instruction": "Estudiante: ¿Cuál es el rol del 'bias' en una neurona?", "response": "El bias es un término constante que se añade a la suma ponderada de las entradas. Permite a la neurona desplazar la función de activación, lo que le da la flexibilidad para activarse o no, independientemente de si las entradas son cero, ajustando la frontera de decisión."}
{"instruction": "¿Qué es un Árbol de Decisión y cuál es su principal ventaja?", "response": "Un Árbol de Decisión (DT) es un modelo supervisado que mapea observaciones a conclusiones. Su principal ventaja es que es un modelo de **'caja blanca'**, fácil de entender e interpretar mediante lógica booleana."}
{"instruction": "En el contexto de Árboles de Decisión, ¿qué es el Índice de Gini?", "response": "El Índice de Gini es una medida de impureza o desorden. El algoritmo lo usa para medir qué tan mezcladas están las clases en un nodo. El objetivo es elegir la división que **minimice** este índice en los nodos hijos, creando ramas puras."}
{"instruction": "Estudiante: ¿Qué es el 'peor caso' en el análisis de algoritmos?", "response": "El peor caso (Worst-Case Scenario) es la entrada que hace que el algoritmo tome la mayor cantidad de tiempo posible en ejecutarse. Es lo que define la notación Big O ($O$)."}
{"instruction": "Ejercicio: Escribe las complejidades de tiempo (peor caso) para Selection Sort, Merge Sort y Heap Sort.", "response": "Las complejidades de peor caso son:\n\n* **Selection Sort:** $O(n^2)$\n* **Merge Sort:** $O(n log n)$\n* **Heap Sort:** $O(n log n)$"}
{"instruction": "Define el concepto de 'Factor de Ramificación' (B) en la búsqueda de estados.", "response": "El Factor de Ramificación (B) es el número promedio de sucesores o hijos que tiene un nodo en el árbol de búsqueda. Un B grande aumenta la complejidad exponencial de la búsqueda ciega ($O(B^n)$)."}
{"instruction": "Explica la diferencia entre 'Bias' y 'Variance' en el trade-off de modelos.", "response": "El Bias (Sesgo) es el error por simplificación (Underfitting). La Variance (Varianza) es el error por sensibilidad a los datos de entrenamiento (Overfitting)."}
{"instruction": "¿Qué es la regularización (L1 o L2) y para qué sirve?", "response": "La regularización (ej: L1 o L2) es una técnica para prevenir el Overfitting. Añade una penalización a los pesos grandes en la función de pérdida, forzando al modelo a ser más simple y generalizable."}
{"instruction": "Dime las complejidades promedio de Inserción, Eliminación y Búsqueda en una Tabla Hash.", "response": "En el caso promedio, las tres operaciones tienen una complejidad de **O(1)** (tiempo constante)."}
{"instruction": "Estudiante: ¿Qué significa que un algoritmo de búsqueda sea 'Completo'?", "response": "Un algoritmo de búsqueda es **completo** si **garantiza que encontrará una solución, siempre y cuando esa solución exista**. Por ejemplo, BFS es completo, mientras que DFS sin control de ciclos no lo es."}
{"instruction": "Define el concepto de 'Algoritmo Voraz' (Greedy Algorithm).", "response": "Un algoritmo voraz toma la decisión **localmente óptima** en cada etapa con la esperanza de que esta decisión conduzca a una solución globalmente óptima. Ejemplos son Dijkstra y Prim."}
{"instruction": "Ejercicio: ¿Es la operación XOR linealmente separable? ¿Por qué sí o por qué no?", "response": "No, la operación XOR (OR Exclusivo) **NO es linealmente separable**. No se puede trazar una sola línea recta para separar las clases. Requiere un modelo no lineal (MLP) para su solución."}
{"instruction": "Explica el rol del 'Input Gate' en una celda LSTM.", "response": "El Input Gate (Puerta de Entrada) decide cuánta información nueva (el valor actual de la entrada) se va a permitir que pase y actualice el estado de la celda."}
{"instruction": "¿Qué son los 'Sistemas Multi-Agente' (SMA)?", "response": "Los SMA son sistemas compuestos por varios agentes inteligentes que interactúan (cooperan, compiten o negocian) para lograr objetivos individuales o colectivos."}
{"instruction": "Diferencia entre un Árbol y un Grafo.", "response": "Un Árbol es un tipo especial de grafo no dirigido y conexo que **no contiene ciclos**. Un Grafo es una estructura más general que puede contener ciclos y ser no conexa."}
{"instruction": "Explica el proceso de Tokenización en NLP.", "response": "La tokenización es el proceso de dividir un texto en unidades más pequeñas llamadas 'tokens', que pueden ser palabras o caracteres. Es el primer paso en el procesamiento del lenguaje."}
{"instruction": "Estudiante: ¿Para qué se usa un Diccionario o Mapa (Map)?", "response": "Un Diccionario (o Tabla Hash) es una colección de pares clave-valor. Es ideal para búsquedas rápidas, con un tiempo promedio de acceso de O(1)."}
{"instruction": "Dime la complejidad de tiempo de Merge Sort en el peor y mejor caso.", "response": "Merge Sort es un algoritmo estable y tiene una complejidad temporal de **O(n log n)** en el peor caso, el mejor caso y el caso promedio."}
{"instruction": "¿Qué hace el algoritmo K-Nearest Neighbors (KNN)?", "response": "KNN es un algoritmo de clasificación y regresión que se basa en la distancia. Clasifica un nuevo punto de dato asignándole la etiqueta de clase más común entre sus 'K' vecinos más cercanos."}
{"instruction": "Explica la arquitectura básica de una Red Neuronal Recurrente (RNN).", "response": "Una RNN está diseñada para trabajar con datos secuenciales (texto o series de tiempo). Tiene una conexión recurrente que le permite recordar información de entradas anteriores a través de una 'memoria de contexto' o estado oculto."}
{"instruction": "¿Qué es la función de pérdida (Loss Function)?", "response": "La función de pérdida cuantifica la diferencia entre la predicción del modelo y el valor real. El objetivo del entrenamiento es minimizar esta función. Ejemplos: Entropía Cruzada (clasificación), Error Cuadrático Medio (regresión)."}
{"instruction": "Diferencia entre el Algoritmo de Dijkstra y el Algoritmo Bellman-Ford.", "response": "Dijkstra es más rápido pero solo funciona con aristas de peso **no negativo**. Bellman-Ford es más lento pero puede manejar aristas de peso **negativo** (siempre que no haya ciclos negativos)."}
{"instruction": "Explica el concepto de 'Factor de Carga' en una Tabla Hash.", "response": "El Factor de Carga es la relación entre el número de elementos almacenados y el número de cubetas. Un factor alto aumenta las colisiones y degrada el rendimiento de $O(1)$ a $O(n)$."}
{"instruction": "Ejercicio: Escribe el pseudocódigo para la Inserción de un elemento en el inicio de una Lista Enlazada Simple.", "response": "```pseudocode\nFUNCTION InsertarAlInicio(Lista, Valor):\n1.  NuevoNodo = Nuevo_Nodo(Valor)\n2.  NuevoNodo.siguiente = Lista.cabeza\n3.  Lista.cabeza = NuevoNodo\nEND FUNCTION\n// Complejidad O(1)\n```"}
{"instruction": "Estudiante: ¿Por qué en un Árbol AVL las operaciones son siempre $O(log n)$?", "response": "Porque el Árbol AVL es un BST que se **auto-balancea**. Su propiedad de balanceo garantiza que la altura del árbol nunca crezca más allá de $log n$, asegurando la eficiencia en todas las operaciones, incluso en el peor caso."}
{"instruction": "¿Qué es un problema de Satisfacción de Restricciones (CSP)?", "response": "Un CSP se define por variables, dominios de valores posibles y un conjunto de restricciones que limitan las combinaciones válidas. El objetivo es encontrar una asignación que satisfaga todas las restricciones (ej: n-Puzzle, Coloreado de Mapas)."}
{"instruction": "Explica la heurística de Distancia Manhattan y su uso.", "response": "La Distancia Manhattan se calcula como la suma de las diferencias absolutas de las coordenadas: $|x_1 - x_2| + |y_1 - y_2|$. Es la distancia que se recorre en un patrón de cuadrícula y se usa como heurística admisible en el algoritmo A*."}
{"instruction": "¿Qué hace el algoritmo Floyd-Warshall?", "response": "Floyd-Warshall encuentra los **caminos más cortos entre todos los pares de vértices** en un grafo dirigido con pesos. Su complejidad es $O(V^3)$."}
{"instruction": "Diferencia entre Búsqueda Lineal y Búsqueda Binaria en términos de eficiencia.", "response": "La Búsqueda Lineal tiene $O(n)$ (lineal), siendo ineficiente para grandes conjuntos. La Búsqueda Binaria tiene $O(log n)$ (logarítmica), siendo mucho más eficiente, pero solo funciona en listas ordenadas."}
{"instruction": "¿Qué es la complejidad O(n log n)?", "response": "La complejidad $O(n log n)$ es considerada la eficiencia óptima para los algoritmos de ordenamiento basados en comparaciones."}
{"instruction": "Explica la diferencia entre 'Overfitting' y 'Underfitting'.", "response": "El Overfitting ocurre cuando el modelo memoriza el ruido (Alta Varianza) y falla en la generalización. El Underfitting ocurre cuando el modelo es demasiado simple (Alto Sesgo) y no aprende los patrones esenciales."}
{"instruction": "¿Qué son los 'Eigenfaces' y para qué sirven?", "response": "Los Eigenfaces (caras propias) son los vectores principales obtenidos por PCA en un conjunto de imágenes de rostros. Sirven para la compresión y el reconocimiento facial."}
{"instruction": "Define el algoritmo 'Bubble Sort'.", "response": "Bubble Sort es un algoritmo simple de ordenamiento que repite pasadas por la lista, compara elementos adyacentes y los intercambia si están en el orden incorrecto. Su peor caso es $O(n^2)$."}
{"instruction": "Estudiante: ¿Qué es mejor, el 'Stemming' o la 'Lemmatization'?", "response": "La **Lemmatization** es generalmente mejor. El Stemming es más rápido, pero solo corta la palabra (la raíz puede no ser una palabra real). La Lemmatization usa diccionarios y contexto para devolver la forma base correcta (el lema), lo que es mejor para la precisión semántica."}
{"instruction": "Explica el rol del parámetro 'r' (rank) en la configuración de LoRA.", "response": "El parámetro 'r' (rank) define el **tamaño de las matrices adaptadoras** (A y B) que se entrenan en LoRA. Un 'r' más bajo (ej: 8) ahorra VRAM y entrena menos parámetros, lo cual es ideal para tu GPU."}
{"instruction": "¿Qué hace el algoritmo de Prim en teoría de grafos?", "response": "El algoritmo de Prim encuentra el Árbol Generador Mínimo (MST). Construye el árbol creciendo desde un nodo inicial, agregando la arista de menor peso que conecta un nodo en el MST con uno que aún está fuera."}
{"instruction": "Dime las complejidades de tiempo (peor caso) para Búsqueda Binaria, Quick Sort y Bubble Sort.", "response": "Las complejidades de peor caso son:\n\n* **Búsqueda Binaria:** $O(log n)$\n* **Quick Sort:** $O(n^2)$\n* **Bubble Sort:** $O(n^2)$"}
{"instruction": "Explica la operación AND lógico en términos de un Perceptrón.", "response": "La operación AND (salida 1 solo si ambas entradas son 1) es linealmente separable. Se puede resolver con un Perceptrón simple con pesos $w1=1, w2=1$ y un sesgo $b=-1.5$."}
{"instruction": "¿Qué es la complejidad $O(n!)$? Da un ejemplo.", "response": "La complejidad factorial $O(n!)$ es la más ineficiente. El tiempo de ejecución se dispara con $n$. Un ejemplo es el algoritmo de fuerza bruta para el Vendedor Viajero (TSP)."}
{"instruction": "Define qué es un Grafo Acíclico Dirigido (DAG).", "response": "Un DAG es un grafo dirigido que no contiene ciclos. Se utiliza para modelar dependencias u órdenes secuenciales."}
{"instruction": "Estudiante: ¿Qué es la 'Fuga de Datos' (Data Leakage) al preprocesar?", "response": "La Fuga de Datos ocurre si la información del conjunto de **prueba** influye en el **entrenamiento**. Se evita aplicando transformaciones (como la normalización o TF-IDF) solo al conjunto de entrenamiento, y luego usando ese mismo transformador para aplicar la transformación al conjunto de prueba."}
{"instruction": "Explica el rol del 'Output Gate' en una celda LSTM.", "response": "El Output Gate (Puerta de Salida) decide qué parte del estado de la celda se va a exponer como la salida final y el estado oculto para el siguiente paso de tiempo."}
{"instruction": "Diferencia entre un ciclo y un camino en un grafo.", "response": "Un ciclo es un camino cerrado que empieza y termina en el mismo vértice. Un camino es una secuencia de aristas que no necesariamente regresa al inicio."}
{"instruction": "¿Qué es el 'Decaimiento del Peso' (Weight Decay)?", "response": "Es una técnica de regularización L2 que penaliza los pesos grandes en la función de pérdida, previniendo el overfitting."}
{"instruction": "Define el problema del 'Coloring Map' (Coloreado de Mapas) en términos de CSP.", "response": "Es un CSP donde las variables son las regiones, los dominios son los colores, y la restricción es que dos regiones adyacentes no pueden tener el mismo color."}
{"instruction": "Explica qué es un Árbol Generador Mínimo (MST).", "response": "Un MST es un subgrafo conexo que conecta todos los vértices con el menor peso total posible, sin ciclos."}
{"instruction": "Dime la fórmula de la Precisión (Precision) en clasificación.", "response": "Precisión = $VP / (VP + FP)$ (Verdaderos Positivos / (Verdaderos Positivos + Falsos Positivos))."}
{"instruction": "Estudiante: ¿Qué es un problema linealmente separable?", "response": "Es un problema de clasificación donde se puede trazar una sola línea o hiperplano para separar perfectamente las clases."}
{"instruction": "Explica qué es la 'Matriz de Confusión'.", "response": "La Matriz de Confusión es una tabla para evaluar el rendimiento de un clasificador, mostrando aciertos (VP, VN) y errores (FP, FN) por clase."}
{"instruction": "¿Qué hace el algoritmo Warshall?", "response": "El algoritmo de Warshall (o Roy-Warshall) se utiliza para encontrar la clausura transitiva de un grafo, es decir, si existe un camino entre cada par de nodos."}
{"instruction": "Dime la complejidad de tiempo de Selection Sort en el peor caso.", "response": "Selection Sort tiene una complejidad temporal de $O(n^2)$ en el peor caso."}
{"instruction": "Explica el concepto de 'Programación Dinámica'.", "response": "Es un método que resuelve problemas complejos dividiéndolos en subproblemas más simples, almacenando las soluciones intermedias para evitar recalcularlas (memorización)."}
{"instruction": "Estudiante: ¿Qué es el 'Undersampling'?", "response": "El Undersampling es una técnica para balancear un dataset desequilibrado. Consiste en reducir el número de ejemplos de la clase mayoritaria hasta que su tamaño sea similar al de la clase minoritaria."}
{"instruction": "Explica qué hace la capa 'Pooling' en una CNN.", "response": "La capa de Pooling (ej: Max-Pooling) reduce la dimensionalidad espacial del mapa de características, haciendo el modelo más eficiente en cómputo y ayudando a prevenir el overfitting."}
{"instruction": "¿Qué es la 'Puerta de Olvido' (Forget Gate) en una celda LSTM?", "response": "La Puerta de Olvido decide qué información del estado de la celda anterior debe ser descartada para manejar dependencias a largo plazo."}
{"instruction": "Diferencia entre 'Regresión Lineal' y 'Regresión Logística'.", "response": "La Regresión Lineal predice un valor continuo. La Regresión Logística, a pesar de su nombre, se usa para clasificación binaria."}
{"instruction": "Explica qué es un 'Agente Inteligente' según la IA.", "response": "Un Agente Inteligente es una entidad autónoma que percibe su entorno (sensores) y actúa sobre él (actuadores) para alcanzar objetivos."}
{"instruction": "Dime las complejidades de tiempo (peor caso) de Insertion Sort, Quick Sort y Búsqueda Secuencial.", "response": "Las complejidades de peor caso son: Insertion Sort $O(n^2)$, Quick Sort $O(n^2)$, y Búsqueda Secuencial $O(n)$."}
{"instruction": "Define el concepto de 'Recorrido Post-Orden' en un árbol.", "response": "El recorrido Post-Orden sigue el orden: Izquierdo, Derecho, Raíz. Es útil para eliminar o liberar la memoria de un árbol."}
{"instruction": "¿Qué son los 'Hyperparámetros' y por qué son importantes?", "response": "Los Hyperparámetros son parámetros de configuración externos (ej: `epochs`, `r`, `learning_rate`) que controlan el proceso de aprendizaje y deben ser elegidos cuidadosamente antes del entrenamiento."}
{"instruction": "Explica la operación NOT lógico en términos de un Perceptrón.", "response": "La operación NOT (salida 1 si entrada es 0) es linealmente separable. Se resuelve con un Perceptrón simple con peso $w1=-1$ y sesgo $b=0.5$."}
{"instruction": "¿Qué es un Árbol Rojo-Negro (Red-Black Tree)?", "response": "Es un Árbol Binario de Búsqueda auto-balanceado que garantiza operaciones de $O(log n)$ en el peor caso, utilizando colores (rojo o negro) para mantener el balance."}
{"instruction": "Estudiante: ¿Qué significa un Recall muy bajo?", "response": "Un Recall (Exhaustividad) muy bajo significa que el modelo está fallando en encontrar una gran parte de los casos positivos reales (muchos Falsos Negativos). Es decir, el modelo es muy cauteloso."}
{"instruction": "Diferencia entre 'Recursión' e 'Iteración'.", "response": "La Recursión es una función que se llama a sí misma y usa la pila (Stack). La Iteración usa bucles (for, while) y es generalmente más eficiente en memoria."}
{"instruction": "¿Qué hace el algoritmo K-Means?", "response": "K-Means es un algoritmo de *clustering* (aprendizaje no supervisado) que agrupa puntos de datos en 'K' grupos basándose en la distancia al centroide."}
{"instruction": "Explica el rol del 'Preorden' (Pre-Order) en un árbol.", "response": "El recorrido Pre-Order sigue el orden: Raíz, Izquierda, Derecha. Es útil para crear una copia de la estructura del árbol."}
{"instruction": "¿Qué hace la función de activación 'Sigmoid'?", "response": "La función Sigmoid mapea cualquier valor real a un valor entre 0 y 1. Es usada para la clasificación binaria, donde la salida se interpreta como probabilidad."}
{"instruction": "Dime la complejidad de tiempo de Selection Sort en el caso promedio.", "response": "Selection Sort tiene una complejidad temporal de $O(n^2)$ en el caso promedio."}
{"instruction": "Explica qué es un Árbol Generador Mínimo (MST).", "response": "Un MST es un subgrafo que conecta todos los vértices sin ciclos y con el menor peso total posible."}
{"instruction": "Estudiante: ¿Qué es 'Overfitting' en un Árbol de Decisión?", "response": "El Overfitting sucede cuando el árbol crece demasiado y aprende el ruido de los datos de entrenamiento. Se combate con la poda (pruning) o limitando la profundidad."}
{"instruction": "Define el algoritmo 'Floyd-Warshall'.", "response": "Floyd-Warshall encuentra los caminos más cortos entre todos los pares de vértices en un grafo con pesos."}
{"instruction": "¿Qué es la complejidad $O(n^3)$?", "response": "La complejidad $O(n^3)$ (cúbica) significa que el tiempo de ejecución crece proporcionalmente al cubo del tamaño de la entrada. Es típica de tres bucles anidados."}
{"instruction": "Explica la operación OR lógico en términos de un Perceptrón.", "response": "La operación OR (salida 1 si al menos una entrada es 1) es linealmente separable. Se resuelve con $w1=1, w2=1$ y $b=-0.5$."}
{"instruction": "Dime la complejidad de tiempo de Insertion Sort en el peor caso.", "response": "El peor caso de Insertion Sort es $O(n^2)$."}
{"instruction": "Explica qué es un 'Feature Vector' (Vector de Características).", "response": "Es la representación numérica de un objeto o dato (ej: un cliente) mediante sus atributos clave, que se usa como entrada para los modelos."}
{"instruction": "¿Qué es la 'Adquisición de Conocimiento' según el Empirismo?", "response": "El Empirismo (Locke) sostiene que el conocimiento se adquiere principalmente a través de la experiencia sensorial ('tabula rasa')."}
{"instruction": "Define el algoritmo 'Bubble Sort' y su mejor caso.", "response": "Bubble Sort es un algoritmo de ordenamiento. Su mejor caso es $O(n)$ si la lista ya está ordenada."}
{"instruction": "Explica qué son las 'Redes Generativas Antagónicas' (GAN).", "response": "Las GAN consisten en una red Generadora y una Discriminadora que compiten para crear datos ultra realistas."}
{"instruction": "¿Qué son los 'Sistemas Expertos'?", "response": "Los Sistemas Expertos son programas de IA que imitan la toma de decisiones de un experto humano usando una base de conocimiento y un motor de inferencia."}
{"instruction": "Define la complejidad $O(n log n)$.", "response": "La complejidad $O(n log n)$ es el tiempo óptimo para el ordenamiento por comparación."}
{"instruction": "Explica qué es una 'Tupla' en Python y por qué es inmutable.", "response": "Una Tupla es una colección ordenada similar a una lista, pero es **inmutable**, lo que significa que no puede ser modificada una vez creada (ej: no se pueden agregar o eliminar elementos)."}
{"instruction": "¿Qué hace el algoritmo K-Nearest Neighbors (KNN)?", "response": "KNN clasifica un nuevo dato asignándole la clase más común entre sus 'K' vecinos más cercanos en el espacio de características."}
{"instruction": "Explica qué son las 'Capsule Networks'.", "response": "Las Capsule Networks usan 'cápsulas' (grupos de neuronas) para capturar la orientación y posición espacial de los objetos en imágenes, superando las limitaciones de las CNN en este aspecto."}
{"instruction": "Dime la fórmula de la Distancia Manhattan.", "response": "Distancia Manhattan = $|x_1 - x_2| + |y_1 - y_2|$."}
{"instruction": "Explica el rol de la función de activación 'ReLU'.", "response": "ReLU (Rectified Linear Unit) introduce no-linealidad en la red. Si la entrada es positiva, devuelve el valor; si es negativa, devuelve cero. Es vital para aprender patrones complejos."}
{"instruction": "¿Qué hace el algoritmo de Búsqueda Binaria?", "response": "La Búsqueda Binaria encuentra la posición de un valor en una lista **ordenada** eliminando la mitad del espacio de búsqueda en cada paso."}
{"instruction": "Estudiante: ¿Qué es el error por 'Alto Sesgo'?", "response": "El error por Alto Sesgo (Bias) es el error introducido cuando el modelo es demasiado simple y no puede capturar los patrones esenciales en los datos (Underfitting)."}
{"instruction": "Dime la complejidad de tiempo de Merge Sort en el caso promedio.", "response": "El caso promedio de Merge Sort es $O(n log n)$."}
{"instruction": "Explica qué es la 'Matriz de Adyacencia'.", "response": "La Matriz de Adyacencia es una representación de un grafo donde el elemento $[i, j]$ indica si hay una arista entre el nodo $i$ y el nodo $j$."}
{"instruction": "¿Qué es la 'Fuga de Datos' (Data Leakage)?", "response": "La Fuga de Datos ocurre cuando la información del conjunto de prueba influye en el entrenamiento, inflando artificialmente el rendimiento del modelo."}
{"instruction": "Define el algoritmo 'Selection Sort'.", "response": "Selection Sort encuentra el elemento más pequeño de la parte no ordenada de la lista y lo intercambia con el primer elemento no ordenado. Su complejidad es $O(n^2)$."}
{"instruction": "Explica el rol del 'Input Gate' y la 'Puerta de Olvido' en una LSTM.", "response": "El Input Gate decide cuánta información nueva entra. La Puerta de Olvido decide qué información anterior debe ser descartada."}
{"instruction": "¿Qué es el 'Decaimiento del Peso' (Weight Decay)?", "response": "Es una forma de regularización L2 que penaliza los pesos grandes para prevenir el overfitting."}
{"instruction": "Dime las complejidades de tiempo (peor caso) de Bubble Sort y Quick Sort.", "response": "Ambos tienen una complejidad de $O(n^2)$ en el peor caso."}
{"instruction": "Explica el concepto de 'Factor de Carga' en una Tabla Hash.", "response": "El Factor de Carga es la relación entre el número de elementos y el número de cubetas; un factor alto degrada el rendimiento de O(1) a O(n)."}
{"instruction": "¿Qué hace el algoritmo Kruskal?", "response": "Kruskal encuentra el Árbol Generador Mínimo (MST) seleccionando la arista de menor peso que no forme un ciclo."}
{"instruction": "Define el concepto de 'Grafo Bipartito'.", "response": "Un Grafo Bipartito es aquel cuyos vértices se pueden dividir en dos conjuntos, sin aristas dentro de un mismo conjunto."}
{"instruction": "Explica qué es la 'Regularización L1' (Lasso).", "response": "La Regularización L1 añade una penalización proporcional al valor absoluto de los pesos y puede llevar los pesos menos importantes a cero (selección de características)."}
{"instruction": "¿Qué es un Árbol AVL y su propiedad de balanceo?", "response": "Un Árbol AVL es un BST auto-balanceado. Su propiedad de balanceo es que la diferencia de altura de los subárboles de cualquier nodo nunca es mayor a 1."}
{"instruction": "Dime la fórmula de la Distancia Euclidiana.", "response": "Distancia Euclidiana = $sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$."}
{"instruction": "Explica el rol del 'Output Gate' en una celda LSTM.", "response": "El Output Gate decide qué parte del estado de la celda se expone como salida y estado oculto para el siguiente paso."}
{"instruction": "¿Qué es el 'Overfitting' y cómo lo detectas?", "response": "El Overfitting se detecta cuando el modelo tiene alta precisión en entrenamiento y baja precisión en el conjunto de prueba (validación)."}
{"instruction": "Define el algoritmo 'Prim'.", "response": "Prim encuentra el MST construyendo el árbol desde un nodo inicial, agregando la arista más barata que conecta el árbol con un nodo fuera de él."}
{"instruction": "Estudiante: ¿Qué son los 'Hyperparámetros' de un modelo y cuáles debo cuidar más en LoRA?", "response": "Los Hyperparámetros son configuraciones externas (ej: `r`, `lora_alpha`, `epochs`) que controlan el proceso de aprendizaje y deben ser elegidos cuidadosamente antes del entrenamiento."}
{"instruction": "Explica el concepto de 'Cohesión' en diseño de software.", "response": "Cohesión es el grado en que los elementos dentro de un módulo trabajan juntos para una sola tarea. Se busca alta cohesión para facilitar el mantenimiento y la reutilización."}
{"instruction": "Dime la complejidad de tiempo de Quick Sort en el caso promedio.", "response": "La complejidad promedio de Quick Sort es $O(n log n)$."}
{"instruction": "Explica qué es un Árbol Generador Mínimo (MST).", "response": "Un MST es un subgrafo conexo que conecta todos los vértices sin ciclos y con el menor peso total posible."}
{"instruction": "¿Qué hace el algoritmo de Búsqueda Binaria?", "response": "La Búsqueda Binaria encuentra la posición de un valor en una lista **ordenada** eliminando la mitad del espacio de búsqueda en cada paso."}
{"instruction": "Explica la arquitectura básica de una Red Neuronal Convolucional (CNN).", "response": "Una CNN usa capas de convolución para detectar características (bordes) y capas de pooling para reducir la dimensionalidad, siendo ideal para imágenes."}
{"instruction": "Define el problema de 'los caníbales y los monjes' en términos de espacio de estados.", "response": "El estado se define por (Mo, Co, Me, Ce, C). La restricción es que los caníbales nunca deben superar en número a los monjes en ninguna orilla."}
{"instruction": "Estudiante: ¿Cuál es el rol de la capa 'Softmax' en clasificación multiclase?", "response": "La capa Softmax convierte las salidas crudas de la red en una **distribución de probabilidad** (valores entre 0 y 1 que suman 1), lo que permite interpretar la probabilidad de cada clase."}
{"instruction": "Explica el rol del 'bias' (sesgo) en una neurona.", "response": "El bias es un término constante que ajusta el umbral de activación de la neurona, permitiéndole activarse o no independientemente de si las entradas son cero."}
{"instruction": "Dime la complejidad de tiempo de Merge Sort en el peor caso.", "response": "La complejidad de Merge Sort es $O(n log n)$ en el peor caso."}
{"instruction": "¿Qué es la 'Programación Dinámica'?", "response": "Es un método que resuelve problemas complejos dividiéndolos en subproblemas, almacenando las soluciones intermedias para evitar recalcularlas (memorización)."}
{"instruction": "Explica la complejidad $O(log n)$.", "response": "La complejidad logarítmica significa que el tiempo de ejecución crece muy lentamente a medida que aumenta el tamaño de la entrada. Es la eficiencia de la Búsqueda Binaria."}
{"instruction": "Define el algoritmo 'Selection Sort'.", "response": "Selection Sort encuentra el elemento más pequeño y lo pone en la primera posición no ordenada. Su complejidad es $O(n^2)$."}
{"instruction": "Estudiante: ¿Qué significa un Recall muy bajo?", "response": "Un Recall muy bajo significa que el modelo está fallando en encontrar una gran parte de los casos positivos reales (muchos Falsos Negativos), es decir, es demasiado cauteloso."}
{"instruction": "Explica la diferencia entre 'Búsqueda Ciega' y 'Búsqueda Heurística'.", "response": "La Búsqueda Ciega no usa información del objetivo (BFS, DFS). La Búsqueda Heurística usa una función para estimar la distancia al objetivo (A*)."}
{"instruction": "¿Qué hace el algoritmo de Dijkstra?", "response": "Dijkstra encuentra el camino más corto desde un nodo de origen hacia todos los demás nodos en un grafo con pesos no negativos."}
{"instruction": "Diferencia entre Stack (Pila) y Queue (Cola).", "response": "Stack usa LIFO (Last-In, First-Out). Queue usa FIFO (First-In, First-Out)."}
{"instruction": "Explica qué es el 'Factor de Ramificación' (B) en la búsqueda de estados.", "response": "El Factor de Ramificación (B) es el número promedio de sucesores por nodo, y su valor afecta la complejidad exponencial de la búsqueda ciega."}
{"instruction": "¿Qué es la maldición de la dimensionalidad?", "response": "La maldición de la dimensionalidad es el problema que surge al trabajar con muchas características, donde los datos se vuelven dispersos y el modelo requiere exponencialmente más datos para generalizar."}
{"instruction": "Define el término 'Admisible' para una heurística en el algoritmo A*.", "response": "Una heurística es admisible si nunca sobreestima el costo real para alcanzar la meta ($h(n) le h^*(n)$)."}
{"instruction": "Explica qué son los 'Sistemas Multi-Agente' (SMA).", "response": "Los SMA son sistemas compuestos por varios agentes inteligentes que interactúan para lograr objetivos colectivos."}
{"instruction": "Dime la fórmula de la Distancia Manhattan.", "response": "Distancia Manhattan = $|x_1 - x_2| + |y_1 - y_2|$."}
{"instruction": "Explica el rol del 'Target' (Etiqueta) en el Aprendizaje Supervisado.", "response": "El Target (Etiqueta) es la respuesta correcta o el valor que el modelo intenta predecir, lo que 'supervisa' el entrenamiento."}
{"instruction": "Estudiante: ¿Qué es el 'Overfitting' en un modelo y cómo lo detectas?", "response": "El Overfitting se detecta cuando el modelo tiene alta precisión en entrenamiento y baja precisión en el conjunto de prueba (validación)."}
{"instruction": "Define el algoritmo 'Bubble Sort'.", "response": "Bubble Sort es un algoritmo simple que compara e intercambia elementos adyacentes. Su peor caso es $O(n^2)$."}
{"instruction": "Explica la complejidad $O(n^2)$.", "response": "La complejidad $O(n^2)$ (cuadrática) significa que el tiempo de ejecución crece proporcionalmente al cuadrado del tamaño de la entrada. Un ejemplo clásico es Bubble Sort."}
{"instruction": "Dime la complejidad de tiempo de Quick Sort en el caso promedio.", "response": "La complejidad promedio de Quick Sort es $O(n log n)$."}
{"instruction": "Estudiante: ¿Qué es mejor, el 'Stemming' o la 'Lemmatization'?", "response": "La **Lemmatization** es generalmente mejor. El Stemming es más rápido, pero la Lemmatization devuelve la forma base correcta (el lema)."}
{"instruction": "Explica qué es un Grafo Conexo.", "response": "Un Grafo Conexo es un grafo donde existe un camino entre cualquier par de vértices."}
{"instruction": "Define el Algoritmo Voraz (Greedy Algorithm).", "response": "Un Algoritmo Voraz toma la decisión localmente óptima en cada etapa, con la esperanza de alcanzar el óptimo global."}
{"instruction": "Explica el rol del 'Target Encoding' para variables categóricas.", "response": "El Target Encoding reemplaza cada categoría con el valor promedio del target para esa categoría, siendo una alternativa al One-Hot Encoding."}
{"instruction": "¿Qué es la complejidad $O(n)$?", "response": "La complejidad $O(n)$ (lineal) significa que el tiempo de ejecución crece directamente proporcional al tamaño de la entrada."}
{"instruction": "Explica qué es un Árbol Binario de Búsqueda (BST).", "response": "Un BST es un Árbol Binario que sigue la regla de ordenamiento: izquierda < raíz < derecha, lo que permite búsquedas rápidas."}
{"instruction": "Diferencia entre un Árbol y un Grafo.", "response": "Un Árbol es un tipo especial de grafo que es acíclico y conexo."}
{"instruction": "Estudiante: ¿Qué hace la función de activación 'Tanh'?", "response": "La función Tanh (Tangente Hiperbólica) introduce no-linealidad y mapea las entradas a un rango entre -1 y 1, centrada en cero, lo que facilita el entrenamiento."}
{"instruction": "¿Qué es un problema Linealmente Separable?", "response": "Es un problema de clasificación donde se puede trazar una sola línea para separar perfectamente las clases."}
{"instruction": "Explica la operación NOT lógico en términos de un Perceptrón.", "response": "La operación NOT es linealmente separable. Se resuelve con un Perceptrón con peso $w1=-1$ y sesgo $b=0.5$."}
{"instruction": "Dime la complejidad de tiempo de Insertion Sort en el caso promedio.", "response": "Insertion Sort tiene una complejidad temporal de $O(n^2)$ en el caso promedio."}
{"instruction": "¿Qué es la Matriz de Adyacencia en un grafo?", "response": "La Matriz de Adyacencia es una representación de un grafo donde el elemento $[i, j]$ indica si hay una arista entre el nodo $i$ y el nodo $j$."}
{"instruction": "Explica la complejidad $O(n log n)$.", "response": "La complejidad $O(n log n)$ es considerada la eficiencia óptima para el ordenamiento por comparación."}
{"instruction": "¿Qué son los 'Sistemas Ubicuos'?", "response": "Los Sistemas Ubicuos implican la integración invisible de la computación en el entorno cotidiano, siendo 'context-aware'."}
{"instruction": "Define el algoritmo 'Quick Sort'.", "response": "Quick Sort es un algoritmo de ordenamiento que usa la técnica de 'divide y vencerás'. Su complejidad promedio es $O(n log n)$."}
{"instruction": "¿Qué es el 'Decaimiento del Peso' (Weight Decay)?", "response": "Es una forma de regularización L2 que penaliza los pesos grandes para prevenir el overfitting."}
{"instruction": "Explica el rol del 'Input Gate' en una celda LSTM.", "response": "El Input Gate decide cuánta información nueva se va a permitir que entre y actualice el estado de la celda."}
{"instruction": "Dime la complejidad de tiempo de Selection Sort en el peor caso.", "response": "Selection Sort tiene una complejidad temporal de $O(n^2)$ en el peor caso."}
{"instruction": "Estudiante: ¿Qué significa que un algoritmo de búsqueda sea 'Óptimo'?", "response": "Un algoritmo de búsqueda es **óptimo** si **garantiza que encontrará el camino de menor costo** entre el estado inicial y el objetivo."}
{"instruction": "Explica el rol de la función de activación 'ReLU'.", "response": "ReLU introduce no-linealidad en la red y es vital para que el modelo aprenda patrones complejos."}
{"instruction": "Diferencia entre 'Regresión Lineal' y 'Regresión Logística'.", "response": "La Regresión Lineal predice un valor continuo. La Regresión Logística se usa para clasificación binaria."}
{"instruction": "¿Qué son las 'Redes Generativas Antagónicas' (GAN)?", "response": "Las GAN consisten en una red Generadora y una Discriminadora que compiten para crear datos ultra realistas."}
{"instruction": "Define el algoritmo 'Prim'.", "response": "Prim encuentra el Árbol Generador Mínimo (MST) construyendo el árbol desde un nodo inicial."}
{"instruction": "¿Qué son los 'Sistemas Expertos'?", "response": "Los Sistemas Expertos imitan la toma de decisiones de un experto humano usando una base de conocimiento y un motor de inferencia."}
{"instruction": "Explica qué es un Grafo Acíclico Dirigido (DAG).", "response": "Un DAG es un grafo dirigido que no contiene ciclos."}
{"instruction": "¿Qué es el 'Factor de Carga' en una Tabla Hash?", "response": "El Factor de Carga es la relación entre el número de elementos y el número de cubetas; un factor alto degrada el rendimiento de O(1) a O(n)."}
{"instruction": "Dime la complejidad de tiempo de Merge Sort en el caso promedio.", "response": "La complejidad de Merge Sort es $O(n log n)$ en el caso promedio."}
{"instruction": "Explica el rol del 'Output Gate' en una celda LSTM.", "response": "El Output Gate decide qué parte del estado de la celda se expone como salida y estado oculto."}
{"instruction": "Define el algoritmo 'Selection Sort'.", "response": "Selection Sort encuentra el elemento más pequeño y lo intercambia con el primer elemento no ordenado. Su complejidad es $O(n^2)$."}
{"instruction": "Estudiante: ¿Qué es el error por 'Alto Sesgo'?", "response": "El error por Alto Sesgo (Bias) es el error introducido cuando el modelo es demasiado simple y no puede capturar los patrones esenciales en los datos (Underfitting)."}
{"instruction": "Explica qué es un Árbol AVL y su propiedad de balanceo.", "response": "Un Árbol AVL es un BST auto-balanceado que garantiza operaciones de $O(log n)$ en el peor caso."}
{"instruction": "Dime la complejidad de tiempo de Quick Sort en el peor caso.", "response": "La complejidad de Quick Sort es $O(n^2)$ en el peor caso."}
{"instruction": "Explica la operación AND lógico en términos de un Perceptrón.", "response": "La operación AND es linealmente separable. Se resuelve con $w1=1, w2=1$ y $b=-1.5$."}
{"instruction": "Dime la complejidad de tiempo de Insertion Sort en el caso promedio.", "response": "La complejidad de Insertion Sort es $O(n^2)$ en el caso promedio."}
{"instruction": "Explica la complejidad $O(n)$.", "response": "La complejidad $O(n)$ (lineal) significa que el tiempo de ejecución crece directamente proporcional al tamaño de la entrada."}
{"instruction": "¿Qué es la Matriz de Adyacencia en un grafo?", "response": "La Matriz de Adyacencia es una representación de un grafo donde el elemento $[i, j]$ indica si hay una arista entre el nodo $i$ y el nodo $j$."}
{"instruction": "Define el algoritmo 'Bubble Sort'.", "response": "Bubble Sort es un algoritmo simple que compara e intercambia elementos adyacentes. Su peor caso es $O(n^2)$."}
{"instruction": "Explica qué es un Árbol Generador Mínimo (MST).", "response": "Un MST es un subgrafo conexo que conecta todos los vértices sin ciclos y con el menor peso total posible."}
{"instruction": "Estudiante: ¿Qué es el 'Overfitting' en un modelo y cómo lo combates?", "response": "El Overfitting se combate con técnicas de Regularización (L1, L2), Dropout, Early Stopping, o usando más datos de entrenamiento."}
{"instruction": "Explica la complejidad $O(log n)$.", "response": "La complejidad logarítmica significa que el tiempo de ejecución crece muy lentamente a medida que aumenta el tamaño de la entrada."}
{"instruction": "Define el término 'Admisible' para una heurística en el algoritmo A*.", "response": "Una heurística es admisible si nunca sobreestima el costo real para alcanzar la meta ($h(n) le h^*(n)$)."}
{"instruction": "Diferencia entre Stack (Pila) y Queue (Cola).", "response": "Stack usa LIFO. Queue usa FIFO."}
{"instruction": "¿Qué es la maldición de la dimensionalidad?", "response": "La maldición de la dimensionalidad es el problema que surge al trabajar con muchas características, donde los datos se vuelven dispersos y el modelo requiere exponencialmente más datos para generalizar."}
{"instruction": "Explica el rol del 'Input Gate' y la 'Puerta de Olvido' en una celda LSTM.", "response": "El Input Gate decide cuánta información nueva entra. La Puerta de Olvido decide qué información anterior debe ser descartada."}
{"instruction": "Dime la complejidad de tiempo de Merge Sort en el peor caso.", "response": "La complejidad de Merge Sort es $O(n log n)$ en el peor caso."}
{"instruction": "Explica la arquitectura básica de una Red Neuronal Convolucional (CNN).", "response": "Una CNN usa capas de convolución para detectar características (bordes) y capas de pooling para reducir la dimensionalidad, siendo ideal para imágenes."}